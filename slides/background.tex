\begin{frame}{Merkle trees}
    \begin{columns}[c]
        \begin{column}{0.5\textwidth}
            It is a binary tree $T$ of height $H$ with $2^H$ leaves and
            $2^{H} - 1$ internal
nodes. Each leaf stores the cryptographic hash of the underlying data, rather than
the raw data itself. The same cryptographic hash function is applied recursively at
internal nodes, which store the hash of the concatenation of their two children.
            $$n_{parent} = f(n_{left} || n_{right})$$
        \end{column}
        \begin{column}{0.5\textwidth}
            \centering
            \begin{tikzpicture}[
              every node/.style={font=\tiny},
              leaf/.style={draw, circle, minimum size=7mm},
              hash/.style={draw, rectangle, rounded corners=2pt,
              minimum width=10mm, minimum height=7mm, 
              red/.style={draw=red},
              sibling distance=1cm,
              align=center},
              node distance=.6cm
            ]
            % leaves
            \node[leaf,] (data0) {$data_0$};
            \node[leaf, right=of data0] (data1) {$data_1$};
            \node[leaf, right=of data1] (data2) {$data_2$};
            \node[leaf, right=of data2] (data3) {$data_3$};
            % leaf-hash nodes with two lines (inline math for each line)
            \node[hash, above=0.2cm of data0] (n0) {\(\mathbf{node_0}\)\\ \(f(data_0)\)};
            \node[hash, above=0.2cm of data1] (n1) {\(\mathbf{node_1}\)\\ \(f(data_1)\)};
            \node[hash, above=0.2cm of data2] (n2) {\(\mathbf{node_2}\)\\ \(f(data_2)\)};
            \node[hash, above=0.2cm of data3] (n3) {\(\mathbf{node_3}\)\\ \(f(data_3)\)};
            % parents
            \node[hash, above=of $(n0)!0.5!(n1)$] (p01) {\(\mathbf{node_{01}}\)\\ \(f(node_0\Vert node_1)\)};
            \node[hash, above=of $(n2)!0.5!(n3)$] (p23) {\(\mathbf{node_{23}}\)\\ \(f(node_2\Vert node_3)\)};
            % root
            \node[hash, above=of $(p01)!0.5!(p23)$] (root) {\(\textbf{root}\)\\ \(f(node_{01}\Vert node_{23})\)};
            % edges with arrows
            \foreach \a/\b in {data0/n0, data1/n1, data2/n2, data3/n3, n0/p01, n1/p01, n2/p23, n3/p23, p01/root, p23/root}
              \draw[->] (\a) -- (\b);
            \end{tikzpicture}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Merkle trees -- Lib}
    \begin{columns}[c]
        \begin{column}{0.7\textwidth}
            A dedicated Rust library was developed to efficiently compute Merkle tree root hashes.
            \begin{table}[h!]
                \centering
                \footnotesize % or \small, \scriptsize, \tiny
                \begin{tabular}{|l|c|c|c|}
                \hline
                    \textbf{Hash function} & \textbf{5 MB} & \textbf{10 MB} & \textbf{15 MB} \\
                \hline
                    SHA-256   & 89.901 ms  & 178.42 ms  & 268.53 ms \\
                    Keccak-256 & 521.49 ms & 1.1334 s   & 1.3438 s \\
                    BLAKE3    & 73.091 ms  & 154.68 ms  & 219.79 ms \\
                \hline
                \end{tabular}
            \end{table}
        \end{column}
        \begin{column}{0.3\textwidth}
            \centering
            \includegraphics[width=.4\linewidth]{static/rust-logo.png}
        \end{column}
    \end{columns}

\end{frame}

\begin{frame}{Raft}
A consensus protocol, where each server on a cluster is a follower, a candidate
or a leader. There is a single leader, responsible for sending messages to other servers via the Raft log.

\centering
\includegraphics[width=.4\linewidth]{static/raft-logo.png}

\end{frame}
