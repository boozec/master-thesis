\appendix

\chapter{Listings}
\pagenumbering{roman}

\section{Protobuf definition for \texttt{Agent} service} \label{code:protobuf-for-agent}
\begin{listing}[H]
\caption{Protobuf definitions for the \texttt{Agent} service, used for communication between gateways and agents, as well as among agents themselves. The file is located in \texttt{internal/proto/agent.proto}.}
\begin{minted}[linenos,fontsize=\footnotesize]{protobuf}
service Agent {
    rpc SendShard(ShardRequest) returns (ShardResponse) {}
    rpc GetShard(ShardGetRequest) returns (ShardGetResponse) {}
    rpc AckShard(ShardAckRequest) returns (ShardAckResponse) {}
    rpc GetRootHash(RootHashRequest) returns (RootHashResponse) {}
    rpc JoinRaft(JoinRequest) returns (JoinResponse) {}
}

message ShardRequest {
    string filename = 1; int64 index = 2; bytes data = 3;
}

message ShardGetRequest {
    string filename = 1; int64 index = 2;
}

message ShardAckRequest {
    string filename = 1; int64 index = 2; bytes roots = 3;
}

message ShardResponse {
    string filename = 1; bytes salt = 2;
}

message ShardGetResponse { bytes data = 1; }
message ShardAckResponse { bool status = 1; }
message RootHashRequest { bytes folder = 1; }
message RootHashResponse { bytes hash = 1; }
// ...
\end{minted}
\end{listing}


\section{Gateway Upload Handler Implementation} \label{code:upload-handler}

\begin{listing}[H]
\caption{Upload handler: Gateway orchestrates file encryption, Reed-Solomon shard creation, and transmission to agents via the \texttt{rpc.SendShard} wrapper.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func UploadHandler(w http.ResponseWriter, r *http.Request) {
    // Open the file in byte format.
    // Generate a key and encrypt the file with it.
    // Encrypt the local file using a random key.
    ciphertext, err := cryptography.Enc(file, key)
    
    // Create N+K shards from the encrypted file ([][]byte).
    shardBytes, err := reedSolomon.Create(N, K, ciphertext)

    // Generate a "good" salt to extend the filename.
    // Send each shard to a different agent.
    for i, shard := range shardBytes {
        resp, err := rpc.SendShard(
            cfg.Agents[i], filename+salt, i, shard,
        )

        if err != nil {
            // Handle error
        }
    }
    
    // Build a JSON response for the client.
    jsonResponse, _ := json.Marshal(/* ... */)

    w.Header().Set("Content-Type", "application/json")
    w.Write(jsonResponse)
}

\end{minted}
\end{listing}

\section{SendShard RPC Wrapper Implementation} \label{code:rpc-send-shard}

\begin{listing}[H]
\caption{\texttt{SendShard} wrapper: intermediate function that establishes a gRPC connection to the target Agent, forwards the shard data to the generated gRPC client stub in \texttt{agent\_grpc.pb.go}, and returns the response.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func SendShard(agent, filename string, index int, 
    data []byte) (*pb.ShardResponse, error) {
    dialCtx, dialCancel := 
        context.WithTimeout(context.Background(), 100*time.Millisecond)
	defer dialCancel()

    conn, _ := grpc.DialContext(dialCtx, agent,
            grpc.WithTransportCredentials(insecure.NewCredentials()),
            grpc.WithBlock())
    defer conn.Close()

    // Instantiate the gRPC client for the Agent service.
    c := pb.NewAgentClient(conn) 

    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()

    // Call the SendShard procedure for the i-th shard of the file.
    resp, _ := c.SendShard(ctx, &pb.ShardRequest{
        Filename: filename, Index: int64(index), Data: data,
    })

    return resp, nil
}
\end{minted}
\end{listing}

\section{Gateway Download Handler Implementation} \label{code:download-handler}

\begin{listing}[H]
\caption{Download handler: logic that retrieves all shards of a file via the \texttt{rpc.GetAllShards} wrapper, reconstructs the file using Reed-Solomon, decrypts it, and returns it as a download to the user.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func DownloadHandler(w http.ResponseWriter, r *http.Request) {
    // Retrieve the salt for a given filename 
    // to reconstruct the exact file saved on agents.
    endFile := getEndFile(filename, salt)

    // Retrieve all shards from agents
    shards, _ := rpc.GetAllShards(endFile)

    // Reconstruct the entire file using Reed-Solomon,
    // and store it at endFile path
    _ = reedSolomon.Reconstruct(cfg.N, cfg.K, endFile, shards)
    // Decrypt the reconstructed file and store it as filename

    // Return the plaintext file as an attachment
    w.Header()
        .Set("Content-Disposition",
            fmt.Sprintf("attachment; filename=%s", filename),
        )
    content, _ = ioutil.ReadFile(filename)

    // Handle possible errors and clear temporary files

    w.Write(content)
}
\end{minted}
\end{listing}


\section{Agent Service Initialization and gRPC Server Setup} \label{code:agent-main-go}

\begin{listing}[H]
\caption{Agent service startup. The gRPC server is initialized and registered, and the node joins or bootstraps a Raft cluster.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
import (
    pb "<path_with_proto_files>"
    // ...
)

// Server implements the gRPC service defined in the Protobuf file.
type Server struct {
    pb.UnimplementedAgentServer
    RaftServer *raft.Server
    // Other fields
}

s := grpc.NewServer()
reflection.Register(s)
server := server.Server{}

// Register the gRPC server with the generated Protobuf bindings.
pb.RegisterAgentServer(s, &server)

server.RaftServer = newRaft(ctx, ..., ..., ..., ...)

lis, _ := net.Listen("tcp", uri)
s.Serve(lis)
\end{minted}
\end{listing}

\section{Raft Node Initialization} \label{code:new-raft-function}

\begin{listing}[H]
\caption{Partial implementation of the \texttt{newRaft} function, which initializes the Raft consensus node.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
import (
    "github.com/hashicorp/raft"
    boltdb "github.com/hashicorp/raft-boltdb"
    // ...
)

func newRaft(ctx context.Context, bootstrap bool, id, raftAddress string,
             fsm raft.FSM) (*raft.Raft, *raft.NetworkTransport, error) {
    conf := raft.DefaultConfig()
    conf.LocalID = raft.ServerID(id)

    // Define the base directory for Raft persistence.

    logs, _ := boltdb.NewBoltStore(filepath.Join(baseDir, "logs.dat"))
    stable, _ := boltdb.NewBoltStore(filepath.Join(baseDir, "stable.dat"))
    snaps, _ := raft.NewFileSnapshotStore(baseDir, 3, os.Stderr)

    addr, _ := net.ResolveTCPAddr("tcp", raftAddress)
    transport, _ := raft.NewTCPTransport(
        raftAddress, addr, 3, 10*time.Second, os.Stderr)

    r, _ := raft.NewRaft(conf, fsm, logs, stable, snaps, transport)

    if bootstrap {
        cfg := raft.Configuration{
            Servers: []raft.Server{{
                    ID:      conf.LocalID,
                    Address: transport.LocalAddr(),
                },
            },
        }
        _ = r.BootstrapCluster(cfg).Error()
    }

    return r, transport, nil
}
\end{minted}
\end{listing}


\section{Client-Side Raft Join Request} \label{code:grpc-call-join-request}

\begin{listing}[H]
\caption{Client-side gRPC call to join an existing Raft cluster. The joining agent dials a Raft member and invokes the \texttt{JoinRaft} RPC with its address and identifier.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
// Establish a connection to a Raft member.
dialCtx, dialCancel := context.WithTimeout(context.Background(),
                                    100*time.Millisecond)
defer dialCancel()

conn, err := grpc.DialContext(dialCtx, "<url-of-Raft-member-to-join>",
    grpc.WithTransportCredentials(insecure.NewCredentials()),
    grpc.WithBlock())

c := pb.NewAgentClient(conn)

// Send a JoinRaft request with the new node's ID and Raft address.
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()

_, err = c.JoinRaft(ctx, &pb.JoinRequest{
    Address: raftAddress, // Address such as 0.0.0.0:4002
    Id:      node, // Identifier such as nodeB
})
\end{minted}
\end{listing}

\section{Server-Side Raft Join Handler} \label{code:grpc-response-join-request}

\begin{listing}[H]
\caption{Server-side handler for \texttt{JoinRaft}. The bootstrap node receives a join request and updates the Raft cluster configuration by invoking the \texttt{join} helper function.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func (s *Server) JoinRaft(ctx context.Context,
        in *pb.JoinRequest) (*pb.JoinResponse, error) {
    address := in.GetAddress()
    id := in.GetId()

    // Attempt to add the new server to the Raft cluster.
    if err := join(s.RaftServer, id, address); err != nil {
        // Handle error
    }

    return &pb.JoinResponse{}, nil
}


// If a server with the same ID or address already exists, it is removed before
// the new server is added as a voter.
func join(r *raft.Raft, nodeId, addr string) error {
    configFuture := r.GetConfiguration()

    for _, srv := range configFuture.Configuration().Servers {
        if srv.ID == raft.ServerID(nodeId) ||
            srv.Address == raft.ServerAddress(addr) {
            if srv.ID == raft.ServerID(nodeId) &&
                srv.Address == raft.ServerAddress(addr) {
                return nil
            }
            // Remove the existing server before re-adding.
            _ = r.RemoveServer(srv.ID, 0, 0)
        }
    }

    // Add the new server as a voting member of the Raft cluster.
    f := r.AddVoter(raft.ServerID(nodeId), raft.ServerAddress(addr), 0, 0)
    if f.Error() != nil {
        return f.Error()
    }
    return nil
}
\end{minted}
\end{listing}

\section{Server-Side SendShard Handler} \label{code:send-shard-server}

\begin{listing}[H]
\caption{Server-side handler for \texttt{SendShard}. Retrieves folder roots, stores the shard locally, and forwards root information to the Raft leader.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func (s *Server) SendShard(ctx context.Context,
    in *pb.ShardRequest) (*pb.ShardResponse, error) {
    fname := in.GetFilename()
    index := in.GetIndex()
    data := in.GetData()
    filename := fname[:len(fname)-2]
    salt := fname[len(fname)-2:]

    go func() {
        // Compute top-level and second-level folder roots
        rootLvl1, _ := merkletree.FolderRootHash(path.folderLvl1)
        rootLvl2, _ := merkletree.FolderRootHash(path.folderLvl2)

        // Prepare the acknowledgement message including both roots
        req := &pb.ShardAckRequest{
            Filename: filename + salt,
            Index:    int64(index),
            Roots:    append(rootLvl1, rootLvl2...),
        }

        // Forward the roots to the leader or process locally 
        // if this node is the leader
        if s.Store.Raft.State() == raft.Leader {
            _, err = s.AckShard(ctx, req)
        } else {
            _, err = c.AckShard(ctx, req)
        }
    }()

    return &pb.ShardResponse{Filename: path, Salt: []byte(salt)}, nil
}
\end{minted}
\end{listing}

\section{Server-Side GetShard Handler} \label{code:get-shard-server}
\begin{listing}
\caption{Server-side handler for \texttt{GetShard}. Retrieves the requested shard from local storage and returns its content.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func (s *Server) GetShard(ctx context.Context,
in *pb.ShardGetRequest) (*pb.ShardGetResponse, error) {
    filename := in.GetFilename()
    index := in.GetIndex()

    // Resolve the actual path of the requested shard
    f, _ := os.Open(path)
    content, _ := ioutil.ReadAll(f)

    return &pb.ShardGetResponse{Data: content}, nil
}
\end{minted}
\end{listing}


\section{Raft Log Command Structure} \label{code:command-struct-for-raft}

\begin{listing}[H]
\caption{Command definition used for Raft log entries. Each command is identified by an opcode and carries an action payload.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
const (
    UploadAck OpCode = iota // Acknowledge the successful storage of a shard
    StoreRootHash // Store a Merkle tree root hash
    StoreAgentHash // Store a Merkle tree hash for a specific agent
    SignalCorruption // Store the corruption status of a folder
)

type Command struct {
    Code OpCode `json:"code"`
    Action interface{} `json:"action"`
}
\end{minted}
\end{listing}


\section{Server-Side AckShard Handler} \label{code:ack-shard}
\begin{listing}[H]
\caption{Server-side handler for \texttt{AckShard}. Updates shard acknowledgments, stores per-agent hashes, and records Merkle roots in the Raft log.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func (s *Server) AckShard(ctx context.Context,
    in *pb.ShardAckRequest) (*pb.ShardAckResponse, error) {
    filename := in.GetFilename()
    index := in.GetIndex()
    agentHashes := in.GetRoots()

    // Split concatenated roots into two 32-byte values
    agentRoots := [][]byte{agentHashes[:64], agentHashes[64:]}

    // Mark the shard as acknowledged
    done := make([]bool, N+K)
    done[index] = true
    shardAcknoledge(s.RaftServer, filename, done)

    path := ... // Retrieve the final path
    toplevel := path.folderLvl1
    secondlevel := path.folderLvl2

    // Store per-agent Merkle roots
    saveAgentHash(s.RaftServer, index,
        [][]byte{toplevel, secondlevel}, agentRoots)

    // Compute and store global Merkle roots for the folders
    root1, _ := merkletree.RootHash(hashes1[toplevel])
    root2, _ := merkletree.RootHash(hashes2[secondlevel])
    saveRoot(s.RaftServer, [][]byte{toplevel, secondlevel},
            [][]byte{root1, root2})

    return &pb.ShardAckResponse{Status: true}, nil
}
\end{minted}
\end{listing}


\section{Raft Log Entry Helper Functions} \label{code:raft-method-to-add-log}

\begin{listing}[H]
\caption{Helper functions for applying shard acknowledgments, Merkle roots, and per-agent hashes to the Raft log.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
func shardAcknoledge(r raft.Server, filename string, done []bool) error {
    c := Command{
        Code: UploadAck,
        Action: ShardDone{ Filename: []byte(filename), Done: done },
    }

    raftRequestData, _ := json.Marshal(c)
    return r.Apply([]byte(raftRequestData), 1time.Second).Error()
}

func saveRoot(r raft.Server, folders [][]byte, hashes [][]byte) error {
    c := Command{
        Code: StoreRootHash,
        Action: MerkletreeRootHash{ Folder1: folders[0], RootHash1: hashes[0],
            Folder2: folders[1], RootHash2: hashes[1] },
    }

    raftRequestData, _ := json.Marshal(c)
    return r.Apply([]byte(raftRequestData), 1time.Second).Error()
}

func saveAgentHash(r raft.Server, agentId int64, folders [][]byte,
    hashes [][]byte) error {
    c := Command{
        Code: StoreAgentHash,
        Action: MerkletreeHash{
            AgentId: agentId, Folder1: folders[0], AgentHash1: hashes[0],
            Folder2: folders[1], AgentHash2: hashes[1] },
    }

    raftRequestData, _ := json.Marshal(c)
    return r.Apply([]byte(raftRequestData), 1time.Second).Error()
}
\end{minted}
\end{listing}



\section{Merkle Tree Creation in Rust} \label{code:partial-mt-rs-1}

\begin{listing}[H]
\caption{Partial implementation of the Rust binary for Merkle tree creation}
\begin{minted}[linenos,fontsize=\footnotesize]{rust}
let tree = if args.file {
    MerkleTree::from_paths(hasher, args.args)
} else {
    let data: Vec<Vec<u8>> = args.args.into_iter()
                                 .map(|s| s.into_bytes()).collect();
    MerkleTree::new(hasher, data)
};

println!("{}", tree.root().hash());
\end{minted}
\end{listing}

\section{Merkle Proof Verification in Rust} \label{code:partial-mt-rs-2}
\begin{listing}[H]
\caption{Extension of the Rust binary for Merkle proof verification}
\begin{minted}[linenos,fontsize=\footnotesize]{rust}
if let Some(root_hash) = args.proof {
    let nodes = // Build nodes from folders or raw data ...
    let first_node = nodes[0].clone();
    let proofer = DefaultProofer::new(hasher, nodes);
    let proof = proofer.generate(0).expect("Couldn't generate proof");
    let verified = proofer.verify_hash(
                        &proof, first_node.hash().to_string(), &root_hash[..]
                   );
    println!("{}", verified);
} else {
    // Merkle tree creation...
}
\end{minted}
\end{listing}

\section{Merkle Tree Module Prototypes (Go)} \label{code:prototypes-merkletree-module}

\begin{listing}[htp]
\caption{Prototypes of the \texttt{merkletree} Go module}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
// Verify a Merkle tree proof for some `hashes` with a `rootHash`.
func Verify(hashes [][]byte, rootHash []byte) bool { ... }

// Returns the root hash of the Merkle tree generated for a folder in `path`
func FolderRootHash(path string) ([]byte, error) { ... }

// Returns the root hash of the Merkle tree generated for a list of data
func RootHash(data [][]byte) ([]byte, error) { ... }
\end{minted}
\end{listing}


\section{Check Corruption Algorithm} \label{code:check-corruption-algorithm}

\begin{listing}[H]
\caption{Partial implementation of the corruption check algorithm. The leader
verifies Merkle proofs at both top-level and second-level folders, and signals corruption states through the Raft log.}
\begin{minted}[linenos,fontsize=\footnotesize]{go}
for folder1, agentHashes1 := range hashes1 {
    root1 := roots1[folder1]
    data := // Retrieve roots for folder1 using agentHashes1 (backup if needed)
    isCorrupted := merkletree.IsPathCorrupted(data, root1)

    if isCorrupted {
        for folder2, agentHashes2 := range hashes2 {
            if strings.HasPrefix(folder2, folder1) {
                root2 := roots2[folder2]
                data := // Retrieve roots for folder2 using agentHashes2
                isCorruptedLevel2 := merkletree.IsPathCorrupted(data, root2)

                if isCorruptedLevel2 {
                    saveCorruptionState(s.RaftServer, folder2, true)
                } else if corruptions[folder2] {
                    // Folder no longer corrupted, but other subfolders may be.
                    saveCorruptionState(s.RaftServer, folder2, false)
                }
            }
        }
        saveCorruptionState(s.RaftServer, folder1, true)
    } else if corruptions[folder1] {
        // Update corruption status for the top-level folder
        // and its second-level children.
    }
}
\end{minted}
\end{listing}
